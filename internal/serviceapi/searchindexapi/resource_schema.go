// Code generated by terraform-provider-mongodbatlas using `make generate-resource`. DO NOT EDIT.

package searchindexapi

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/mongodb/terraform-provider-mongodbatlas/internal/common/autogen/customtypes"
	"github.com/mongodb/terraform-provider-mongodbatlas/internal/common/customplanmodifier"
)

func ResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"cluster_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Name of the cluster that contains the collection on which to create an Atlas Search index.",
				PlanModifiers:       []planmodifier.String{customplanmodifier.CreateOnly()},
			},
			"collection_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Label that identifies the collection to create an Atlas Search index in.",
				PlanModifiers:       []planmodifier.String{customplanmodifier.CreateOnly()},
			},
			"database": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Label that identifies the database that contains the collection to create an Atlas Search index in.",
				PlanModifiers:       []planmodifier.String{customplanmodifier.CreateOnly()},
			},
			"definition": schema.SingleNestedAttribute{
				Required:            true,
				MarkdownDescription: "The index definition to update the search index to.",
				CustomType:          customtypes.NewObjectType[TFDefinitionModel](ctx),
				Attributes: map[string]schema.Attribute{
					"analyzer": schema.StringAttribute{
						Computed:            true,
						Optional:            true,
						MarkdownDescription: "Specific pre-defined method chosen to convert database field text into searchable words. This conversion reduces the text of fields into the smallest units of text. These units are called a **term** or **token**. This process, known as tokenization, involves making the following changes to the text in fields:\n\n- extracting words\n- removing punctuation\n- removing accents\n- changing to lowercase\n- removing common words\n- reducing words to their root form (stemming)\n- changing words to their base form (lemmatization)\n MongoDB Cloud uses the process you select to build the Atlas Search index.",
					},
					"analyzers": schema.ListNestedAttribute{
						Optional:            true,
						MarkdownDescription: "List of user-defined methods to convert database field text into searchable words.",
						CustomType:          customtypes.NewNestedListType[TFDefinitionAnalyzersModel](ctx),
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"char_filters": schema.ListAttribute{
									Optional:            true,
									MarkdownDescription: "Filters that examine text one character at a time and perform filtering operations.",
									CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
									ElementType:         jsontypes.NormalizedType{},
								},
								"name": schema.StringAttribute{
									Required:            true,
									MarkdownDescription: "Name that identifies the custom analyzer. Names must be unique within an index, and must not start with any of the following strings:\n- `lucene.`\n- `builtin.`\n- `mongodb.`",
								},
								"token_filters": schema.ListAttribute{
									Optional:            true,
									MarkdownDescription: "Filter that performs operations such as:\n\n- Stemming, which reduces related words, such as \"talking\", \"talked\", and \"talks\" to their root word \"talk\".\n\n- Redaction, which is the removal of sensitive information from public documents.",
									CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
									ElementType:         jsontypes.NormalizedType{},
								},
								"tokenizer": schema.StringAttribute{
									Required:            true,
									MarkdownDescription: "Tokenizer that you want to use to create tokens. Tokens determine how Atlas Search splits up text into discrete chunks for indexing.",
									CustomType:          jsontypes.NormalizedType{},
								},
							},
						},
					},
					"fields": schema.ListAttribute{
						Optional:            true,
						MarkdownDescription: "Settings that configure the fields, one per object, to index. You must define at least one \"vector\" type field. You can optionally define \"filter\" type fields also.",
						CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
						ElementType:         jsontypes.NormalizedType{},
					},
					"mappings": schema.SingleNestedAttribute{
						Optional:            true,
						MarkdownDescription: "Index specifications for the collection's fields.",
						CustomType:          customtypes.NewObjectType[TFDefinitionMappingsModel](ctx),
						Attributes: map[string]schema.Attribute{
							"dynamic": schema.StringAttribute{
								Optional:            true,
								MarkdownDescription: "Indicates whether the index uses static, default dynamic, or configurable dynamic mappings. Set to **true** to enable dynamic mapping with default type set or define object to specify the name of the configured type sets for dynamic mapping. If you specify configurable dynamic mappings, you must define the referred type sets in the **typeSets** field. Set to **false** to use only static mappings through **mappings.fields**.",
								CustomType:          jsontypes.NormalizedType{},
							},
							"fields": schema.MapAttribute{
								Optional:            true,
								MarkdownDescription: "One or more field specifications for the Atlas Search index. Required if **mappings.dynamic** is omitted or set to **false**.",
								CustomType:          customtypes.NewMapType[jsontypes.Normalized](ctx),
								ElementType:         jsontypes.NormalizedType{},
							},
						},
					},
					"num_partitions": schema.Int64Attribute{
						Computed:            true,
						Optional:            true,
						MarkdownDescription: "Number of index partitions. Allowed values are [1, 2, 4].",
					},
					"search_analyzer": schema.StringAttribute{
						Computed:            true,
						Optional:            true,
						MarkdownDescription: "Method applied to identify words when searching this index.",
					},
					"stored_source": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "Flag that indicates whether to store all fields (true) on Atlas Search. By default, Atlas doesn't store (false) the fields on Atlas Search.  Alternatively, you can specify an object that only contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see Stored Source Fields.",
						CustomType:          jsontypes.NormalizedType{},
					},
					"synonyms": schema.ListNestedAttribute{
						Optional:            true,
						MarkdownDescription: "Rule sets that map words to their synonyms in this index.",
						CustomType:          customtypes.NewNestedListType[TFDefinitionSynonymsModel](ctx),
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"analyzer": schema.StringAttribute{
									Required:            true,
									MarkdownDescription: "Specific pre-defined method chosen to apply to the synonyms to be searched.",
								},
								"name": schema.StringAttribute{
									Required:            true,
									MarkdownDescription: "Label that identifies the synonym definition. Each **synonym.name** must be unique within the same index definition.",
								},
								"source": schema.SingleNestedAttribute{
									Required:            true,
									MarkdownDescription: "Data set that stores words and their applicable synonyms.",
									CustomType:          customtypes.NewObjectType[TFDefinitionSynonymsSourceModel](ctx),
									Attributes: map[string]schema.Attribute{
										"collection": schema.StringAttribute{
											Required:            true,
											MarkdownDescription: "Label that identifies the MongoDB collection that stores words and their applicable synonyms.",
										},
									},
								},
							},
						},
					},
					"type_sets": schema.ListNestedAttribute{
						Optional:            true,
						MarkdownDescription: "Type sets for the index.",
						CustomType:          customtypes.NewNestedListType[TFDefinitionTypeSetsModel](ctx),
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:            true,
									MarkdownDescription: "Label that identifies the type set name. Each **typeSets.name** must be unique within the same index definition.",
								},
								"types": schema.ListAttribute{
									Optional:            true,
									MarkdownDescription: "List of types associated with the type set. Each type definition must include a \"type\" field specifying the search field type (\"autocomplete\", \"boolean\", \"date\", \"geo\", \"number\", \"objectId\", \"string\", \"token\", or \"uuid\") and may include additional configuration properties specific to that type.",
									CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
									ElementType:         jsontypes.NormalizedType{},
								},
							},
						},
					},
				},
			},
			"group_id": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.\n\n**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.",
				PlanModifiers:       []planmodifier.String{customplanmodifier.CreateOnly()},
			},
			"index_id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Unique 24-hexadecimal digit string that identifies this Atlas Search index.",
			},
			"latest_definition": schema.SingleNestedAttribute{
				Computed:   true,
				CustomType: customtypes.NewObjectType[TFLatestDefinitionModel](ctx),
				Attributes: map[string]schema.Attribute{
					"analyzer": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: "Specific pre-defined method chosen to convert database field text into searchable words. This conversion reduces the text of fields into the smallest units of text. These units are called a **term** or **token**. This process, known as tokenization, involves making the following changes to the text in fields:\n\n- extracting words\n- removing punctuation\n- removing accents\n- changing to lowercase\n- removing common words\n- reducing words to their root form (stemming)\n- changing words to their base form (lemmatization)\n MongoDB Cloud uses the process you select to build the Atlas Search index.",
					},
					"analyzers": schema.ListNestedAttribute{
						Computed:            true,
						MarkdownDescription: "List of user-defined methods to convert database field text into searchable words.",
						CustomType:          customtypes.NewNestedListType[TFLatestDefinitionAnalyzersModel](ctx),
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"char_filters": schema.ListAttribute{
									Computed:            true,
									MarkdownDescription: "Filters that examine text one character at a time and perform filtering operations.",
									CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
									ElementType:         jsontypes.NormalizedType{},
								},
								"name": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: "Name that identifies the custom analyzer. Names must be unique within an index, and must not start with any of the following strings:\n- `lucene.`\n- `builtin.`\n- `mongodb.`",
								},
								"token_filters": schema.ListAttribute{
									Computed:            true,
									MarkdownDescription: "Filter that performs operations such as:\n\n- Stemming, which reduces related words, such as \"talking\", \"talked\", and \"talks\" to their root word \"talk\".\n\n- Redaction, which is the removal of sensitive information from public documents.",
									CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
									ElementType:         jsontypes.NormalizedType{},
								},
								"tokenizer": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: "Tokenizer that you want to use to create tokens. Tokens determine how Atlas Search splits up text into discrete chunks for indexing.",
									CustomType:          jsontypes.NormalizedType{},
								},
							},
						},
					},
					"fields": schema.ListAttribute{
						Computed:            true,
						MarkdownDescription: "Settings that configure the fields, one per object, to index. You must define at least one \"vector\" type field. You can optionally define \"filter\" type fields also.",
						CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
						ElementType:         jsontypes.NormalizedType{},
					},
					"mappings": schema.SingleNestedAttribute{
						Computed:            true,
						MarkdownDescription: "Index specifications for the collection's fields.",
						CustomType:          customtypes.NewObjectType[TFLatestDefinitionMappingsModel](ctx),
						Attributes: map[string]schema.Attribute{
							"dynamic": schema.StringAttribute{
								Computed:            true,
								MarkdownDescription: "Indicates whether the index uses static, default dynamic, or configurable dynamic mappings. Set to **true** to enable dynamic mapping with default type set or define object to specify the name of the configured type sets for dynamic mapping. If you specify configurable dynamic mappings, you must define the referred type sets in the **typeSets** field. Set to **false** to use only static mappings through **mappings.fields**.",
								CustomType:          jsontypes.NormalizedType{},
							},
						},
					},
					"num_partitions": schema.Int64Attribute{
						Computed:            true,
						MarkdownDescription: "Number of index partitions. Allowed values are [1, 2, 4].",
					},
					"search_analyzer": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: "Method applied to identify words when searching this index.",
					},
					"stored_source": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: "Flag that indicates whether to store all fields (true) on Atlas Search. By default, Atlas doesn't store (false) the fields on Atlas Search.  Alternatively, you can specify an object that only contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see Stored Source Fields.",
						CustomType:          jsontypes.NormalizedType{},
					},
					"synonyms": schema.ListNestedAttribute{
						Computed:            true,
						MarkdownDescription: "Rule sets that map words to their synonyms in this index.",
						CustomType:          customtypes.NewNestedListType[TFLatestDefinitionSynonymsModel](ctx),
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"analyzer": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: "Specific pre-defined method chosen to apply to the synonyms to be searched.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: "Label that identifies the synonym definition. Each **synonym.name** must be unique within the same index definition.",
								},
								"source": schema.SingleNestedAttribute{
									Computed:            true,
									MarkdownDescription: "Data set that stores words and their applicable synonyms.",
									CustomType:          customtypes.NewObjectType[TFLatestDefinitionSynonymsSourceModel](ctx),
									Attributes: map[string]schema.Attribute{
										"collection": schema.StringAttribute{
											Computed:            true,
											MarkdownDescription: "Label that identifies the MongoDB collection that stores words and their applicable synonyms.",
										},
									},
								},
							},
						},
					},
					"type_sets": schema.ListNestedAttribute{
						Computed:            true,
						MarkdownDescription: "Type sets for the index.",
						CustomType:          customtypes.NewNestedListType[TFLatestDefinitionTypeSetsModel](ctx),
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: "Label that identifies the type set name. Each **typeSets.name** must be unique within the same index definition.",
								},
								"types": schema.ListAttribute{
									Computed:            true,
									MarkdownDescription: "List of types associated with the type set. Each type definition must include a \"type\" field specifying the search field type (\"autocomplete\", \"boolean\", \"date\", \"geo\", \"number\", \"objectId\", \"string\", \"token\", or \"uuid\") and may include additional configuration properties specific to that type.",
									CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
									ElementType:         jsontypes.NormalizedType{},
								},
							},
						},
					},
				},
			},
			"latest_definition_version": schema.SingleNestedAttribute{
				Computed:            true,
				MarkdownDescription: "Object which includes the version number of the index definition and the time that the index definition was created.",
				CustomType:          customtypes.NewObjectType[TFLatestDefinitionVersionModel](ctx),
				Attributes: map[string]schema.Attribute{
					"created_at": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: "The time at which this index definition was created. This parameter expresses its value in the ISO 8601 timestamp format in UTC.",
					},
					"version": schema.Int64Attribute{
						Computed:            true,
						MarkdownDescription: "The version number associated with this index definition when it was created.",
					},
				},
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Label that identifies this index. Within each namespace, names of all indexes in the namespace must be unique.",
				PlanModifiers:       []planmodifier.String{customplanmodifier.CreateOnly()},
			},
			"queryable": schema.BoolAttribute{
				Computed:            true,
				MarkdownDescription: "Flag that indicates whether the index is queryable on all hosts.",
			},
			"status": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Condition of the search index when you made this request.\n\n- `DELETING`: The index is being deleted.\n- `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.\n- `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.\n- `PENDING`: Atlas has not yet started building the index.\n- `BUILDING`: Atlas is building or re-building the index after an edit.\n- `READY`: The index is ready and can support queries.",
			},
			"status_detail": schema.ListNestedAttribute{
				Computed:            true,
				MarkdownDescription: "List of documents detailing index status on each host.",
				CustomType:          customtypes.NewNestedListType[TFStatusDetailModel](ctx),
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"hostname": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: "Hostname that corresponds to the status detail.",
						},
						"main_index": schema.SingleNestedAttribute{
							Computed:            true,
							MarkdownDescription: "Contains status information about a vector search index.",
							CustomType:          customtypes.NewObjectType[TFStatusDetailMainIndexModel](ctx),
							Attributes: map[string]schema.Attribute{
								"definition": schema.SingleNestedAttribute{
									Computed:            true,
									MarkdownDescription: "The vector search index definition set by the user.",
									CustomType:          customtypes.NewObjectType[TFStatusDetailMainIndexDefinitionModel](ctx),
									Attributes: map[string]schema.Attribute{
										"fields": schema.ListAttribute{
											Computed:            true,
											MarkdownDescription: "Settings that configure the fields, one per object, to index. You must define at least one \"vector\" type field. You can optionally define \"filter\" type fields also.",
											CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
											ElementType:         jsontypes.NormalizedType{},
										},
										"num_partitions": schema.Int64Attribute{
											Computed:            true,
											MarkdownDescription: "Number of index partitions. Allowed values are [1, 2, 4].",
										},
									},
								},
								"definition_version": schema.SingleNestedAttribute{
									Computed:            true,
									MarkdownDescription: "Object which includes the version number of the index definition and the time that the index definition was created.",
									CustomType:          customtypes.NewObjectType[TFStatusDetailMainIndexDefinitionVersionModel](ctx),
									Attributes: map[string]schema.Attribute{
										"created_at": schema.StringAttribute{
											Computed:            true,
											MarkdownDescription: "The time at which this index definition was created. This parameter expresses its value in the ISO 8601 timestamp format in UTC.",
										},
										"version": schema.Int64Attribute{
											Computed:            true,
											MarkdownDescription: "The version number associated with this index definition when it was created.",
										},
									},
								},
								"message": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: "Optional message describing an error.",
								},
								"queryable": schema.BoolAttribute{
									Computed:            true,
									MarkdownDescription: "Flag that indicates whether the index generation is queryable on the host.",
								},
								"status": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: "Condition of the search index when you made this request.\n\n- `DELETING`: The index is being deleted.\n- `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.\n- `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.\n- `PENDING`: Atlas has not yet started building the index.\n- `BUILDING`: Atlas is building or re-building the index after an edit.\n- `READY`: The index is ready and can support queries.",
								},
							},
						},
						"queryable": schema.BoolAttribute{
							Computed:            true,
							MarkdownDescription: "Flag that indicates whether the index is queryable on the host.",
						},
						"staged_index": schema.SingleNestedAttribute{
							Computed:            true,
							MarkdownDescription: "Contains status information about a vector search index.",
							CustomType:          customtypes.NewObjectType[TFStatusDetailStagedIndexModel](ctx),
							Attributes: map[string]schema.Attribute{
								"definition": schema.SingleNestedAttribute{
									Computed:            true,
									MarkdownDescription: "The vector search index definition set by the user.",
									CustomType:          customtypes.NewObjectType[TFStatusDetailStagedIndexDefinitionModel](ctx),
									Attributes: map[string]schema.Attribute{
										"fields": schema.ListAttribute{
											Computed:            true,
											MarkdownDescription: "Settings that configure the fields, one per object, to index. You must define at least one \"vector\" type field. You can optionally define \"filter\" type fields also.",
											CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
											ElementType:         jsontypes.NormalizedType{},
										},
										"num_partitions": schema.Int64Attribute{
											Computed:            true,
											MarkdownDescription: "Number of index partitions. Allowed values are [1, 2, 4].",
										},
									},
								},
								"definition_version": schema.SingleNestedAttribute{
									Computed:            true,
									MarkdownDescription: "Object which includes the version number of the index definition and the time that the index definition was created.",
									CustomType:          customtypes.NewObjectType[TFStatusDetailStagedIndexDefinitionVersionModel](ctx),
									Attributes: map[string]schema.Attribute{
										"created_at": schema.StringAttribute{
											Computed:            true,
											MarkdownDescription: "The time at which this index definition was created. This parameter expresses its value in the ISO 8601 timestamp format in UTC.",
										},
										"version": schema.Int64Attribute{
											Computed:            true,
											MarkdownDescription: "The version number associated with this index definition when it was created.",
										},
									},
								},
								"message": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: "Optional message describing an error.",
								},
								"queryable": schema.BoolAttribute{
									Computed:            true,
									MarkdownDescription: "Flag that indicates whether the index generation is queryable on the host.",
								},
								"status": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: "Condition of the search index when you made this request.\n\n- `DELETING`: The index is being deleted.\n- `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.\n- `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.\n- `PENDING`: Atlas has not yet started building the index.\n- `BUILDING`: Atlas is building or re-building the index after an edit.\n- `READY`: The index is ready and can support queries.",
								},
							},
						},
						"status": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: "Condition of the search index when you made this request.\n\n- `DELETING`: The index is being deleted.\n- `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.\n- `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.\n- `PENDING`: Atlas has not yet started building the index.\n- `BUILDING`: Atlas is building or re-building the index after an edit.\n- `READY`: The index is ready and can support queries.",
						},
					},
				},
			},
			"synonym_mapping_status": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Status that describes this index's synonym mappings. This status appears only if the index has synonyms defined.",
			},
			"synonym_mapping_status_detail": schema.ListAttribute{
				Computed:            true,
				MarkdownDescription: "A list of documents describing the status of the index's synonym mappings on each search host. Only appears if the index has synonyms defined.",
				CustomType:          customtypes.NewListType[jsontypes.Normalized](ctx),
				ElementType:         jsontypes.NormalizedType{},
			},
			"type": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Type of the index. The default type is search.",
				PlanModifiers:       []planmodifier.String{customplanmodifier.CreateOnly()},
			},
			"delete_on_create_timeout": schema.BoolAttribute{
				Computed:            true,
				Optional:            true,
				MarkdownDescription: "Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `true` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `false`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `true`, wait before retrying to allow resource deletion to finish. Default is `true`.",
				PlanModifiers:       []planmodifier.Bool{customplanmodifier.CreateOnlyBoolWithDefault(true)},
			},
			"timeouts": timeouts.Attributes(ctx, timeouts.Opts{
				Create: true,
				Update: true,
			}),
		},
	}
}

type TFModel struct {
	StatusDetail               customtypes.NestedListValue[TFStatusDetailModel]        `tfsdk:"status_detail" autogen:"omitjson"`
	SynonymMappingStatusDetail customtypes.ListValue[jsontypes.Normalized]             `tfsdk:"synonym_mapping_status_detail" autogen:"omitjson"`
	Name                       types.String                                            `tfsdk:"name" autogen:"omitjsonupdate"`
	SynonymMappingStatus       types.String                                            `tfsdk:"synonym_mapping_status" autogen:"omitjson"`
	GroupId                    types.String                                            `tfsdk:"group_id" autogen:"omitjson"`
	IndexID                    types.String                                            `tfsdk:"index_id" autogen:"omitjson"`
	LatestDefinition           customtypes.ObjectValue[TFLatestDefinitionModel]        `tfsdk:"latest_definition" autogen:"omitjson"`
	LatestDefinitionVersion    customtypes.ObjectValue[TFLatestDefinitionVersionModel] `tfsdk:"latest_definition_version" autogen:"omitjson"`
	ClusterName                types.String                                            `tfsdk:"cluster_name" autogen:"omitjson"`
	Timeouts                   timeouts.Value                                          `tfsdk:"timeouts" autogen:"omitjson"`
	Status                     types.String                                            `tfsdk:"status" autogen:"omitjson"`
	Database                   types.String                                            `tfsdk:"database" autogen:"omitjsonupdate"`
	Definition                 customtypes.ObjectValue[TFDefinitionModel]              `tfsdk:"definition"`
	CollectionName             types.String                                            `tfsdk:"collection_name" autogen:"omitjsonupdate"`
	Type                       types.String                                            `tfsdk:"type" autogen:"omitjsonupdate"`
	DeleteOnCreateTimeout      types.Bool                                              `tfsdk:"delete_on_create_timeout" autogen:"omitjson"`
	Queryable                  types.Bool                                              `tfsdk:"queryable" autogen:"omitjson"`
}
type TFDefinitionModel struct {
	Analyzers      customtypes.NestedListValue[TFDefinitionAnalyzersModel] `tfsdk:"analyzers"`
	Fields         customtypes.ListValue[jsontypes.Normalized]             `tfsdk:"fields"`
	Synonyms       customtypes.NestedListValue[TFDefinitionSynonymsModel]  `tfsdk:"synonyms"`
	TypeSets       customtypes.NestedListValue[TFDefinitionTypeSetsModel]  `tfsdk:"type_sets"`
	Analyzer       types.String                                            `tfsdk:"analyzer"`
	Mappings       customtypes.ObjectValue[TFDefinitionMappingsModel]      `tfsdk:"mappings"`
	SearchAnalyzer types.String                                            `tfsdk:"search_analyzer"`
	StoredSource   jsontypes.Normalized                                    `tfsdk:"stored_source"`
	NumPartitions  types.Int64                                             `tfsdk:"num_partitions"`
}
type TFDefinitionAnalyzersModel struct {
	CharFilters  customtypes.ListValue[jsontypes.Normalized] `tfsdk:"char_filters"`
	Name         types.String                                `tfsdk:"name"`
	TokenFilters customtypes.ListValue[jsontypes.Normalized] `tfsdk:"token_filters"`
	Tokenizer    jsontypes.Normalized                        `tfsdk:"tokenizer"`
}
type TFDefinitionMappingsModel struct {
	Dynamic jsontypes.Normalized                       `tfsdk:"dynamic"`
	Fields  customtypes.MapValue[jsontypes.Normalized] `tfsdk:"fields"`
}
type TFDefinitionSynonymsModel struct {
	Analyzer types.String                                             `tfsdk:"analyzer"`
	Name     types.String                                             `tfsdk:"name"`
	Source   customtypes.ObjectValue[TFDefinitionSynonymsSourceModel] `tfsdk:"source"`
}
type TFDefinitionSynonymsSourceModel struct {
	Collection types.String `tfsdk:"collection"`
}
type TFDefinitionTypeSetsModel struct {
	Name  types.String                                `tfsdk:"name"`
	Types customtypes.ListValue[jsontypes.Normalized] `tfsdk:"types"`
}
type TFLatestDefinitionModel struct {
	Analyzers      customtypes.NestedListValue[TFLatestDefinitionAnalyzersModel] `tfsdk:"analyzers" autogen:"omitjson"`
	Fields         customtypes.ListValue[jsontypes.Normalized]                   `tfsdk:"fields" autogen:"omitjson"`
	Synonyms       customtypes.NestedListValue[TFLatestDefinitionSynonymsModel]  `tfsdk:"synonyms" autogen:"omitjson"`
	TypeSets       customtypes.NestedListValue[TFLatestDefinitionTypeSetsModel]  `tfsdk:"type_sets" autogen:"omitjson"`
	Analyzer       types.String                                                  `tfsdk:"analyzer" autogen:"omitjson"`
	Mappings       customtypes.ObjectValue[TFLatestDefinitionMappingsModel]      `tfsdk:"mappings" autogen:"omitjson"`
	SearchAnalyzer types.String                                                  `tfsdk:"search_analyzer" autogen:"omitjson"`
	StoredSource   jsontypes.Normalized                                          `tfsdk:"stored_source" autogen:"omitjson"`
	NumPartitions  types.Int64                                                   `tfsdk:"num_partitions" autogen:"omitjson"`
}
type TFLatestDefinitionAnalyzersModel struct {
	CharFilters  customtypes.ListValue[jsontypes.Normalized] `tfsdk:"char_filters" autogen:"omitjson"`
	Name         types.String                                `tfsdk:"name" autogen:"omitjson"`
	TokenFilters customtypes.ListValue[jsontypes.Normalized] `tfsdk:"token_filters" autogen:"omitjson"`
	Tokenizer    jsontypes.Normalized                        `tfsdk:"tokenizer" autogen:"omitjson"`
}
type TFLatestDefinitionMappingsModel struct {
	Dynamic jsontypes.Normalized `tfsdk:"dynamic" autogen:"omitjson"`
}
type TFLatestDefinitionSynonymsModel struct {
	Analyzer types.String                                                   `tfsdk:"analyzer" autogen:"omitjson"`
	Name     types.String                                                   `tfsdk:"name" autogen:"omitjson"`
	Source   customtypes.ObjectValue[TFLatestDefinitionSynonymsSourceModel] `tfsdk:"source" autogen:"omitjson"`
}
type TFLatestDefinitionSynonymsSourceModel struct {
	Collection types.String `tfsdk:"collection" autogen:"omitjson"`
}
type TFLatestDefinitionTypeSetsModel struct {
	Name  types.String                                `tfsdk:"name" autogen:"omitjson"`
	Types customtypes.ListValue[jsontypes.Normalized] `tfsdk:"types" autogen:"omitjson"`
}
type TFLatestDefinitionVersionModel struct {
	CreatedAt types.String `tfsdk:"created_at" autogen:"omitjson"`
	Version   types.Int64  `tfsdk:"version" autogen:"omitjson"`
}
type TFStatusDetailModel struct {
	Hostname    types.String                                            `tfsdk:"hostname" autogen:"omitjson"`
	MainIndex   customtypes.ObjectValue[TFStatusDetailMainIndexModel]   `tfsdk:"main_index" autogen:"omitjson"`
	StagedIndex customtypes.ObjectValue[TFStatusDetailStagedIndexModel] `tfsdk:"staged_index" autogen:"omitjson"`
	Status      types.String                                            `tfsdk:"status" autogen:"omitjson"`
	Queryable   types.Bool                                              `tfsdk:"queryable" autogen:"omitjson"`
}
type TFStatusDetailMainIndexModel struct {
	Definition        customtypes.ObjectValue[TFStatusDetailMainIndexDefinitionModel]        `tfsdk:"definition" autogen:"omitjson"`
	DefinitionVersion customtypes.ObjectValue[TFStatusDetailMainIndexDefinitionVersionModel] `tfsdk:"definition_version" autogen:"omitjson"`
	Message           types.String                                                           `tfsdk:"message" autogen:"omitjson"`
	Status            types.String                                                           `tfsdk:"status" autogen:"omitjson"`
	Queryable         types.Bool                                                             `tfsdk:"queryable" autogen:"omitjson"`
}
type TFStatusDetailMainIndexDefinitionModel struct {
	Fields        customtypes.ListValue[jsontypes.Normalized] `tfsdk:"fields" autogen:"omitjson"`
	NumPartitions types.Int64                                 `tfsdk:"num_partitions" autogen:"omitjson"`
}
type TFStatusDetailMainIndexDefinitionVersionModel struct {
	CreatedAt types.String `tfsdk:"created_at" autogen:"omitjson"`
	Version   types.Int64  `tfsdk:"version" autogen:"omitjson"`
}
type TFStatusDetailStagedIndexModel struct {
	Definition        customtypes.ObjectValue[TFStatusDetailStagedIndexDefinitionModel]        `tfsdk:"definition" autogen:"omitjson"`
	DefinitionVersion customtypes.ObjectValue[TFStatusDetailStagedIndexDefinitionVersionModel] `tfsdk:"definition_version" autogen:"omitjson"`
	Message           types.String                                                             `tfsdk:"message" autogen:"omitjson"`
	Status            types.String                                                             `tfsdk:"status" autogen:"omitjson"`
	Queryable         types.Bool                                                               `tfsdk:"queryable" autogen:"omitjson"`
}
type TFStatusDetailStagedIndexDefinitionModel struct {
	Fields        customtypes.ListValue[jsontypes.Normalized] `tfsdk:"fields" autogen:"omitjson"`
	NumPartitions types.Int64                                 `tfsdk:"num_partitions" autogen:"omitjson"`
}
type TFStatusDetailStagedIndexDefinitionVersionModel struct {
	CreatedAt types.String `tfsdk:"created_at" autogen:"omitjson"`
	Version   types.Int64  `tfsdk:"version" autogen:"omitjson"`
}
