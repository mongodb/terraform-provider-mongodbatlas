// Code generated by terraform-provider-mongodbatlas using `make generate-resource`. DO NOT EDIT.

package streamconnectionapi

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/mongodb/terraform-provider-mongodbatlas/internal/common/autogen/customtypes"
	"github.com/mongodb/terraform-provider-mongodbatlas/internal/common/autogen/customvalidator"
	"github.com/mongodb/terraform-provider-mongodbatlas/internal/common/customplanmodifier"
)

func ResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"authentication": schema.SingleNestedAttribute{
				Optional:            true,
				MarkdownDescription: "User credentials required to connect to a Kafka Cluster. Includes the authentication type, as well as the parameters for that authentication mode.",
				CustomType:          customtypes.NewObjectType[TFAuthenticationModel](ctx),
				Attributes: map[string]schema.Attribute{
					"client_id": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "OIDC client identifier for authentication to the Kafka cluster.",
					},
					"client_secret": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "OIDC client secret for authentication to the Kafka cluster.",
						Sensitive:           true,
					},
					"mechanism": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "Style of authentication. Can be one of PLAIN, SCRAM-256, SCRAM-512, or OAUTHBEARER.",
					},
					"method": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "SASL OAUTHBEARER authentication method. Can only be OIDC currently.",
					},
					"password": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "Password of the account to connect to the Kafka cluster.",
						Sensitive:           true,
					},
					"sasl_oauthbearer_extensions": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "SASL OAUTHBEARER extensions parameter for additional OAuth2 configuration.",
					},
					"scope": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "OIDC scope parameter defining the access permissions requested.",
					},
					"ssl_certificate": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "SSL certificate for client authentication to Kafka.",
					},
					"ssl_key": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "SSL key for client authentication to Kafka.",
					},
					"ssl_key_password": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "Password for the SSL key, if it is password protected.",
						Sensitive:           true,
					},
					"token_endpoint_url": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "OIDC token endpoint URL for obtaining access tokens.",
					},
					"username": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "Username of the account to connect to the Kafka cluster.",
					},
				},
			},
			"aws": schema.SingleNestedAttribute{
				Optional:            true,
				MarkdownDescription: "AWS configurations for AWS-based connection types.",
				CustomType:          customtypes.NewObjectType[TFAwsModel](ctx),
				Attributes: map[string]schema.Attribute{
					"role_arn": schema.StringAttribute{
						Required:            true,
						MarkdownDescription: "Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account.",
					},
					"test_bucket": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "The name of an S3 bucket used to check authorization of the passed-in IAM role ARN.",
					},
				},
			},
			"bootstrap_servers": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Comma separated list of server addresses.",
			},
			"cluster_project_id": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Unique 24-hexadecimal digit string that identifies the project that contains the configured cluster. Required if the ID does not match the project containing the streams workspace. You must first enable the organization setting.",
			},
			"cluster_name": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Name of the cluster configured for this connection.",
			},
			"config": schema.MapAttribute{
				Optional:            true,
				MarkdownDescription: "A map of Kafka key-value pairs for optional configuration. This is a flat object, and keys can have '.' characters.",
				CustomType:          customtypes.NewMapType[types.String](ctx),
				ElementType:         types.StringType,
			},
			"db_role_to_execute": schema.SingleNestedAttribute{
				Optional:            true,
				MarkdownDescription: "The name of a Built in or Custom DB Role to connect to an Atlas Cluster.",
				CustomType:          customtypes.NewObjectType[TFDbRoleToExecuteModel](ctx),
				Attributes: map[string]schema.Attribute{
					"role": schema.StringAttribute{
						Required:            true,
						MarkdownDescription: "The name of the role to use. Can be a built in role or a custom role.",
					},
					"type": schema.StringAttribute{
						Required:            true,
						MarkdownDescription: "Type of the DB role. Can be either BuiltIn or Custom.",
					},
				},
			},
			"project_id": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Unique 24-hexadecimal digit string that identifies your project.",
				PlanModifiers:       []planmodifier.String{customplanmodifier.CreateOnly()},
			},
			"headers": schema.MapAttribute{
				Optional:            true,
				MarkdownDescription: "A map of key-value pairs that will be passed as headers for the request.",
				CustomType:          customtypes.NewMapType[types.String](ctx),
				ElementType:         types.StringType,
			},
			"connection_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Human-readable label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.",
			},
			"networking": schema.SingleNestedAttribute{
				Optional:            true,
				MarkdownDescription: "Networking configuration for Streams connections.",
				CustomType:          customtypes.NewObjectType[TFNetworkingModel](ctx),
				Attributes: map[string]schema.Attribute{
					"access": schema.SingleNestedAttribute{
						Required:            true,
						MarkdownDescription: "Information about networking access.",
						CustomType:          customtypes.NewObjectType[TFNetworkingAccessModel](ctx),
						Attributes: map[string]schema.Attribute{
							"connection_id": schema.StringAttribute{
								Optional:            true,
								MarkdownDescription: "Reserved. Will be used by PRIVATE_LINK connection type.",
							},
							"name": schema.StringAttribute{
								Optional:            true,
								MarkdownDescription: "Reserved. Will be used by PRIVATE_LINK connection type.",
							},
							"tgw_route_id": schema.StringAttribute{
								Optional:            true,
								MarkdownDescription: "Reserved. Will be used by TRANSIT_GATEWAY connection type.",
							},
							"type": schema.StringAttribute{
								Required:            true,
								MarkdownDescription: "Selected networking type. Either PUBLIC, VPC, PRIVATE_LINK, or TRANSIT_GATEWAY. Defaults to PUBLIC. For VPC, ensure that VPC peering exists and connectivity has been established between Atlas VPC and the VPC where Kafka cluster is hosted for the connection to function properly. TRANSIT_GATEWAY support is coming soon.",
							},
						},
					},
				},
			},
			"schema_registry_provider": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "The Schema Registry provider.",
			},
			"schema_registry_authentication": schema.SingleNestedAttribute{
				Optional:            true,
				MarkdownDescription: "Authentication configuration for Schema Registry.",
				CustomType:          customtypes.NewObjectType[TFSchemaRegistryAuthenticationModel](ctx),
				Attributes: map[string]schema.Attribute{
					"password": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "Password or Private Key for authentication.",
						Sensitive:           true,
					},
					"type": schema.StringAttribute{
						Required:            true,
						MarkdownDescription: "Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry.",
						Validators: []validator.String{
							customvalidator.ValidateDiscriminator(customvalidator.DiscriminatorDefinition{
								Mapping: map[string]customvalidator.VariantDefinition{
									"SASL_INHERIT": {},
									"USER_INFO": {
										Allowed:  []string{"password", "username"},
										Required: []string{"password", "username"},
									},
								},
							}),
						},
					},
					"username": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "Username or Public Key for authentication.",
					},
				},
			},
			"schema_registry_urls": schema.ListAttribute{
				Optional:            true,
				MarkdownDescription: "List of Schema Registry endpoint URLs used by this connection. Each URL must use the http or https scheme and specify a valid host and optional port.",
				CustomType:          customtypes.NewListType[types.String](ctx),
				ElementType:         types.StringType,
			},
			"security": schema.SingleNestedAttribute{
				Optional:            true,
				MarkdownDescription: "Properties for the secure transport connection to Kafka. For SSL, this can include the trusted certificate to use.",
				CustomType:          customtypes.NewObjectType[TFSecurityModel](ctx),
				Attributes: map[string]schema.Attribute{
					"broker_public_certificate": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "A trusted, public x509 certificate for connecting to Kafka over SSL.",
					},
					"protocol": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: "Describes the transport type. Can be either SASL_PLAINTEXT, SASL_SSL, or SSL.",
					},
				},
			},
			"state": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The state of the connection.",
			},
			"workspace_name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Label that identifies the stream workspace.",
				PlanModifiers:       []planmodifier.String{customplanmodifier.CreateOnly()},
			},
			"type": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Type of the connection.",
				Validators: []validator.String{
					customvalidator.ValidateDiscriminator(customvalidator.DiscriminatorDefinition{
						Mapping: map[string]customvalidator.VariantDefinition{
							"AWSKinesisDataStreams": {
								Allowed: []string{"aws", "networking"},
							},
							"AWSLambda": {
								Allowed: []string{"aws"},
							},
							"Cluster": {
								Allowed: []string{"cluster_name", "cluster_project_id", "db_role_to_execute"},
							},
							"Https": {
								Allowed: []string{"headers", "url"},
							},
							"Kafka": {
								Allowed: []string{"authentication", "bootstrap_servers", "config", "networking", "security"},
							},
							"S3": {
								Allowed: []string{"aws", "networking"},
							},
							"Sample": {},
							"SchemaRegistry": {
								Allowed:  []string{"schema_registry_authentication", "schema_registry_provider", "schema_registry_urls"},
								Required: []string{"schema_registry_authentication", "schema_registry_provider", "schema_registry_urls"},
							},
						},
					}),
				},
			},
			"url": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "The url to be used for the request.",
			},
			"delete_on_create_timeout": schema.BoolAttribute{
				Computed:            true,
				Optional:            true,
				MarkdownDescription: "Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `true` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `false`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `true`, wait before retrying to allow resource deletion to finish. Default is `true`.",
				PlanModifiers:       []planmodifier.Bool{customplanmodifier.CreateOnlyBoolWithDefault(true)},
			},
			"timeouts": timeouts.Attributes(ctx, timeouts.Opts{
				Create: true,
				Update: true,
				Delete: true,
			}),
		},
	}
}

type TFModel struct {
	Authentication               customtypes.ObjectValue[TFAuthenticationModel]               `tfsdk:"authentication"`
	Aws                          customtypes.ObjectValue[TFAwsModel]                          `tfsdk:"aws"`
	BootstrapServers             types.String                                                 `tfsdk:"bootstrap_servers"`
	ClusterProjectId             types.String                                                 `tfsdk:"cluster_project_id" apiname:"clusterGroupId"`
	ClusterName                  types.String                                                 `tfsdk:"cluster_name"`
	Config                       customtypes.MapValue[types.String]                           `tfsdk:"config"`
	DbRoleToExecute              customtypes.ObjectValue[TFDbRoleToExecuteModel]              `tfsdk:"db_role_to_execute"`
	ProjectId                    types.String                                                 `tfsdk:"project_id" apiname:"groupId" autogen:"omitjson"`
	Headers                      customtypes.MapValue[types.String]                           `tfsdk:"headers"`
	ConnectionName               types.String                                                 `tfsdk:"connection_name" apiname:"name"`
	Networking                   customtypes.ObjectValue[TFNetworkingModel]                   `tfsdk:"networking"`
	SchemaRegistryProvider       types.String                                                 `tfsdk:"schema_registry_provider" apiname:"provider"`
	SchemaRegistryAuthentication customtypes.ObjectValue[TFSchemaRegistryAuthenticationModel] `tfsdk:"schema_registry_authentication"`
	SchemaRegistryUrls           customtypes.ListValue[types.String]                          `tfsdk:"schema_registry_urls"`
	Security                     customtypes.ObjectValue[TFSecurityModel]                     `tfsdk:"security"`
	State                        types.String                                                 `tfsdk:"state" autogen:"omitjson"`
	WorkspaceName                types.String                                                 `tfsdk:"workspace_name" apiname:"tenantName" autogen:"omitjson"`
	Type                         types.String                                                 `tfsdk:"type"`
	Url                          types.String                                                 `tfsdk:"url"`
	DeleteOnCreateTimeout        types.Bool                                                   `tfsdk:"delete_on_create_timeout" autogen:"omitjson"`
	Timeouts                     timeouts.Value                                               `tfsdk:"timeouts" autogen:"omitjson"`
}
type TFAuthenticationModel struct {
	ClientId                  types.String `tfsdk:"client_id"`
	ClientSecret              types.String `tfsdk:"client_secret" autogen:"sensitive"`
	Mechanism                 types.String `tfsdk:"mechanism"`
	Method                    types.String `tfsdk:"method"`
	Password                  types.String `tfsdk:"password" autogen:"sensitive"`
	SaslOauthbearerExtensions types.String `tfsdk:"sasl_oauthbearer_extensions"`
	Scope                     types.String `tfsdk:"scope"`
	SslCertificate            types.String `tfsdk:"ssl_certificate"`
	SslKey                    types.String `tfsdk:"ssl_key"`
	SslKeyPassword            types.String `tfsdk:"ssl_key_password" autogen:"sensitive"`
	TokenEndpointUrl          types.String `tfsdk:"token_endpoint_url"`
	Username                  types.String `tfsdk:"username"`
}
type TFAwsModel struct {
	RoleArn    types.String `tfsdk:"role_arn"`
	TestBucket types.String `tfsdk:"test_bucket"`
}
type TFDbRoleToExecuteModel struct {
	Role types.String `tfsdk:"role"`
	Type types.String `tfsdk:"type"`
}
type TFNetworkingModel struct {
	Access customtypes.ObjectValue[TFNetworkingAccessModel] `tfsdk:"access"`
}
type TFNetworkingAccessModel struct {
	ConnectionId types.String `tfsdk:"connection_id"`
	Name         types.String `tfsdk:"name"`
	TgwRouteId   types.String `tfsdk:"tgw_route_id"`
	Type         types.String `tfsdk:"type"`
}
type TFSchemaRegistryAuthenticationModel struct {
	Password types.String `tfsdk:"password" autogen:"sensitive"`
	Type     types.String `tfsdk:"type"`
	Username types.String `tfsdk:"username"`
}
type TFSecurityModel struct {
	BrokerPublicCertificate types.String `tfsdk:"broker_public_certificate"`
	Protocol                types.String `tfsdk:"protocol"`
}
