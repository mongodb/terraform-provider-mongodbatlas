package provider_test

import (
	"fmt"
	"regexp"
	"testing"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	providerfw "github.com/hashicorp/terraform-plugin-framework/provider"
	"github.com/hashicorp/terraform-plugin-framework/provider/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource"

	"github.com/mongodb/terraform-provider-mongodbatlas/internal/provider"
)

// TestAutogenResourcesNotEnabled prevents accidental commits including autogenerated resources in the provider.
func TestAutogenResourcesNotEnabled(t *testing.T) {
	t.Parallel()
	prov := provider.NewFrameworkProvider()
	var provReq providerfw.MetadataRequest
	var provRes providerfw.MetadataResponse
	prov.Metadata(t.Context(), provReq, &provRes)
	for _, fn := range prov.Resources(t.Context()) {
		res := fn()
		metadataReq := resource.MetadataRequest{
			ProviderTypeName: provRes.TypeName,
		}
		var metadataRes resource.MetadataResponse
		res.Metadata(t.Context(), metadataReq, &metadataRes)

		// Regex pattern to match resources ending with _api or _api_v followed by any number
		autogenPattern := regexp.MustCompile(`_api(_v\d+)?$`)
		if autogenPattern.MatchString(metadataRes.TypeName) {
			t.Fatalf("Resource %q that is autogenerated can't be enabled in the provider in master yet", metadataRes.TypeName)
		}
	}
}

func TestResourceSchemas(t *testing.T) {
	t.Parallel()
	prov := provider.NewFrameworkProvider()
	var provReq providerfw.MetadataRequest
	var provRes providerfw.MetadataResponse
	prov.Metadata(t.Context(), provReq, &provRes)
	for _, fn := range prov.Resources(t.Context()) {
		res := fn()
		metadataReq := resource.MetadataRequest{
			ProviderTypeName: provRes.TypeName,
		}
		var metadataRes resource.MetadataResponse
		res.Metadata(t.Context(), metadataReq, &metadataRes)

		t.Run(metadataRes.TypeName, func(t *testing.T) {
			schemaRequest := resource.SchemaRequest{}
			schemaResponse := &resource.SchemaResponse{}
			res.Schema(t.Context(), schemaRequest, schemaResponse)
			validateDocumentation(metadataRes.TypeName, schemaResponse)

			if schemaResponse.Diagnostics.HasError() {
				t.Fatalf("Schema method diagnostics: %+v", schemaResponse.Diagnostics)
			}

			if diagnostics := schemaResponse.Schema.ValidateImplementation(t.Context()); diagnostics.HasError() {
				t.Fatalf("Schema validation diagnostics: %+v", diagnostics)
			}
		})
	}
}

func TestDataSourceSchemas(t *testing.T) {
	t.Parallel()
	prov := provider.NewFrameworkProvider()
	var provReq providerfw.MetadataRequest
	var provRes providerfw.MetadataResponse
	prov.Metadata(t.Context(), provReq, &provRes)
	for _, fn := range prov.DataSources(t.Context()) {
		res := fn()
		metadataReq := datasource.MetadataRequest{
			ProviderTypeName: provRes.TypeName,
		}
		var metadataRes datasource.MetadataResponse
		res.Metadata(t.Context(), metadataReq, &metadataRes)

		t.Run(metadataRes.TypeName, func(t *testing.T) {
			schemaRequest := datasource.SchemaRequest{}
			schemaResponse := &datasource.SchemaResponse{}
			res.Schema(t.Context(), schemaRequest, schemaResponse)
			validateDSDocumentation(metadataRes.TypeName, schemaResponse)

			if schemaResponse.Diagnostics.HasError() {
				t.Fatalf("Schema method diagnostics: %+v", schemaResponse.Diagnostics)
			}

			if diagnostics := schemaResponse.Schema.ValidateImplementation(t.Context()); diagnostics.HasError() {
				t.Fatalf("Schema validation diagnostics: %+v", diagnostics)
			}
		})
	}
}

func validateDocumentation(name string, resp *resource.SchemaResponse) {
	checkDescriptor(name, resp.Schema, &resp.Diagnostics)
	validateAttributes(name, resp.Schema.GetAttributes(), &resp.Diagnostics)
	validateBlocks(name, resp.Schema.GetBlocks(), &resp.Diagnostics)
}

func validateDSDocumentation(name string, resp *datasource.SchemaResponse) {
	checkDescriptor(name, resp.Schema, &resp.Diagnostics)
	validateAttributes(name, resp.Schema.GetAttributes(), &resp.Diagnostics)
	validateBlocks(name, resp.Schema.GetBlocks(), &resp.Diagnostics)
}

func validateAttribute(name string, attr schema.Attribute, diagnostics *diag.Diagnostics) {
	checkDescriptor(name, attr, diagnostics)
	if nested, ok := attr.(schema.NestedAttribute); ok {
		validateAttributes(name, nested.GetNestedObject().GetAttributes(), diagnostics)
	}
}

func validateBlock(name string, block schema.Block, diagnostics *diag.Diagnostics) {
	checkDescriptor(name, block, diagnostics)
	validateAttributes(name, block.GetNestedObject().GetAttributes(), diagnostics)
	validateBlocks(name, block.GetNestedObject().GetBlocks(), diagnostics)
}

func validateAttributes[T schema.Attribute](name string, attrs map[string]T, diagnostics *diag.Diagnostics) {
	for k, v := range attrs {
		validateAttribute(name+"."+k, v, diagnostics)
	}
}

func validateBlocks[T schema.Block](name string, blocks map[string]T, diagnostics *diag.Diagnostics) {
	for k, v := range blocks {
		validateBlock(name+"."+k, v, diagnostics)
	}
}

type descriptor interface {
	GetDescription() string
	GetMarkdownDescription() string
}

func checkDescriptor(name string, d descriptor, diagnostics *diag.Diagnostics) {
	if d.GetDescription() != d.GetMarkdownDescription() {
		diagnostics.Append(diag.NewErrorDiagnostic(
			"Conflicting Attribute Description",
			fmt.Sprintf("Description and MarkdownDescription differ for %q.", name),
		))
	}
}
