// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package projectipaddresses

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ProjectIpAddressesDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"group_id": schema.StringAttribute{
				Required:            true,
				Description:         "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.\n\n**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.",
				MarkdownDescription: "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.\n\n**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(24, 24),
					stringvalidator.RegexMatches(regexp.MustCompile("^([a-f0-9]{24})$"), ""),
				},
			},
			"services": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"clusters": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"cluster_name": schema.StringAttribute{
									Computed:            true,
									Description:         "Human-readable label that identifies the cluster.",
									MarkdownDescription: "Human-readable label that identifies the cluster.",
								},
								"inbound": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "List of inbound IP addresses associated with the cluster. If your network allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your application can connect to your Atlas cluster.",
									MarkdownDescription: "List of inbound IP addresses associated with the cluster. If your network allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your application can connect to your Atlas cluster.",
								},
								"outbound": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "List of outbound IP addresses associated with the cluster. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that your Atlas cluster can communicate with your webhooks and KMS.",
									MarkdownDescription: "List of outbound IP addresses associated with the cluster. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that your Atlas cluster can communicate with your webhooks and KMS.",
								},
							},
							CustomType: ClustersType{
								ObjectType: types.ObjectType{
									AttrTypes: ClustersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "IP addresses of clusters.",
						MarkdownDescription: "IP addresses of clusters.",
					},
				},
				CustomType: ServicesType{
					ObjectType: types.ObjectType{
						AttrTypes: ServicesValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "List of IP addresses in a project categorized by services.",
				MarkdownDescription: "List of IP addresses in a project categorized by services.",
			},
		},
	}
}

type ProjectIpAddressesModel struct {
	GroupId  types.String  `tfsdk:"group_id"`
	Services ServicesValue `tfsdk:"services"`
}

var _ basetypes.ObjectTypable = ServicesType{}

type ServicesType struct {
	basetypes.ObjectType
}

func (t ServicesType) Equal(o attr.Type) bool {
	other, ok := o.(ServicesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServicesType) String() string {
	return "ServicesType"
}

func (t ServicesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clustersAttribute, ok := attributes["clusters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clusters is missing from object`)

		return nil, diags
	}

	clustersVal, ok := clustersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clusters expected to be basetypes.ListValue, was: %T`, clustersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServicesValue{
		Clusters: clustersVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewServicesValueNull() ServicesValue {
	return ServicesValue{
		state: attr.ValueStateNull,
	}
}

func NewServicesValueUnknown() ServicesValue {
	return ServicesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServicesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServicesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServicesValue Attribute Value",
				"While creating a ServicesValue value, a missing attribute value was detected. "+
					"A ServicesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServicesValue Attribute Type",
				"While creating a ServicesValue value, an invalid attribute value was detected. "+
					"A ServicesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServicesValue Attribute Value",
				"While creating a ServicesValue value, an extra attribute value was detected. "+
					"A ServicesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServicesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServicesValueUnknown(), diags
	}

	clustersAttribute, ok := attributes["clusters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clusters is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	clustersVal, ok := clustersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clusters expected to be basetypes.ListValue, was: %T`, clustersAttribute))
	}

	if diags.HasError() {
		return NewServicesValueUnknown(), diags
	}

	return ServicesValue{
		Clusters: clustersVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewServicesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServicesValue {
	object, diags := NewServicesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServicesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServicesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServicesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServicesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServicesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServicesValueMust(ServicesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServicesType) ValueType(ctx context.Context) attr.Value {
	return ServicesValue{}
}

var _ basetypes.ObjectValuable = ServicesValue{}

type ServicesValue struct {
	Clusters basetypes.ListValue `tfsdk:"clusters"`
	state    attr.ValueState
}

func (v ServicesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["clusters"] = basetypes.ListType{
		ElemType: ClustersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Clusters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["clusters"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServicesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServicesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServicesValue) String() string {
	return "ServicesValue"
}

func (v ServicesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	clusters := types.ListValueMust(
		ClustersType{
			basetypes.ObjectType{
				AttrTypes: ClustersValue{}.AttributeTypes(ctx),
			},
		},
		v.Clusters.Elements(),
	)

	if v.Clusters.IsNull() {
		clusters = types.ListNull(
			ClustersType{
				basetypes.ObjectType{
					AttrTypes: ClustersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Clusters.IsUnknown() {
		clusters = types.ListUnknown(
			ClustersType{
				basetypes.ObjectType{
					AttrTypes: ClustersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"clusters": basetypes.ListType{
			ElemType: ClustersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"clusters": clusters,
		})

	return objVal, diags
}

func (v ServicesValue) Equal(o attr.Value) bool {
	other, ok := o.(ServicesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Clusters.Equal(other.Clusters) {
		return false
	}

	return true
}

func (v ServicesValue) Type(ctx context.Context) attr.Type {
	return ServicesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServicesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"clusters": basetypes.ListType{
			ElemType: ClustersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClustersType{}

type ClustersType struct {
	basetypes.ObjectType
}

func (t ClustersType) Equal(o attr.Type) bool {
	other, ok := o.(ClustersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClustersType) String() string {
	return "ClustersType"
}

func (t ClustersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clusterNameAttribute, ok := attributes["cluster_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_name is missing from object`)

		return nil, diags
	}

	clusterNameVal, ok := clusterNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_name expected to be basetypes.StringValue, was: %T`, clusterNameAttribute))
	}

	inboundAttribute, ok := attributes["inbound"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inbound is missing from object`)

		return nil, diags
	}

	inboundVal, ok := inboundAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inbound expected to be basetypes.ListValue, was: %T`, inboundAttribute))
	}

	outboundAttribute, ok := attributes["outbound"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outbound is missing from object`)

		return nil, diags
	}

	outboundVal, ok := outboundAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outbound expected to be basetypes.ListValue, was: %T`, outboundAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClustersValue{
		ClusterName: clusterNameVal,
		Inbound:     inboundVal,
		Outbound:    outboundVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewClustersValueNull() ClustersValue {
	return ClustersValue{
		state: attr.ValueStateNull,
	}
}

func NewClustersValueUnknown() ClustersValue {
	return ClustersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClustersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClustersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClustersValue Attribute Value",
				"While creating a ClustersValue value, a missing attribute value was detected. "+
					"A ClustersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClustersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClustersValue Attribute Type",
				"While creating a ClustersValue value, an invalid attribute value was detected. "+
					"A ClustersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClustersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClustersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClustersValue Attribute Value",
				"While creating a ClustersValue value, an extra attribute value was detected. "+
					"A ClustersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClustersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClustersValueUnknown(), diags
	}

	clusterNameAttribute, ok := attributes["cluster_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_name is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	clusterNameVal, ok := clusterNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_name expected to be basetypes.StringValue, was: %T`, clusterNameAttribute))
	}

	inboundAttribute, ok := attributes["inbound"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inbound is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	inboundVal, ok := inboundAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inbound expected to be basetypes.ListValue, was: %T`, inboundAttribute))
	}

	outboundAttribute, ok := attributes["outbound"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outbound is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	outboundVal, ok := outboundAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outbound expected to be basetypes.ListValue, was: %T`, outboundAttribute))
	}

	if diags.HasError() {
		return NewClustersValueUnknown(), diags
	}

	return ClustersValue{
		ClusterName: clusterNameVal,
		Inbound:     inboundVal,
		Outbound:    outboundVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewClustersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClustersValue {
	object, diags := NewClustersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClustersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClustersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClustersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClustersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClustersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClustersValueMust(ClustersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClustersType) ValueType(ctx context.Context) attr.Value {
	return ClustersValue{}
}

var _ basetypes.ObjectValuable = ClustersValue{}

type ClustersValue struct {
	ClusterName basetypes.StringValue `tfsdk:"cluster_name"`
	Inbound     basetypes.ListValue   `tfsdk:"inbound"`
	Outbound    basetypes.ListValue   `tfsdk:"outbound"`
	state       attr.ValueState
}

func (v ClustersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["cluster_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["inbound"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["outbound"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ClusterName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_name"] = val

		val, err = v.Inbound.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inbound"] = val

		val, err = v.Outbound.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["outbound"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClustersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClustersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClustersValue) String() string {
	return "ClustersValue"
}

func (v ClustersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	inboundVal, d := types.ListValue(types.StringType, v.Inbound.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cluster_name": basetypes.StringType{},
			"inbound": basetypes.ListType{
				ElemType: types.StringType,
			},
			"outbound": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	outboundVal, d := types.ListValue(types.StringType, v.Outbound.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cluster_name": basetypes.StringType{},
			"inbound": basetypes.ListType{
				ElemType: types.StringType,
			},
			"outbound": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"cluster_name": basetypes.StringType{},
		"inbound": basetypes.ListType{
			ElemType: types.StringType,
		},
		"outbound": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cluster_name": v.ClusterName,
			"inbound":      inboundVal,
			"outbound":     outboundVal,
		})

	return objVal, diags
}

func (v ClustersValue) Equal(o attr.Value) bool {
	other, ok := o.(ClustersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClusterName.Equal(other.ClusterName) {
		return false
	}

	if !v.Inbound.Equal(other.Inbound) {
		return false
	}

	if !v.Outbound.Equal(other.Outbound) {
		return false
	}

	return true
}

func (v ClustersValue) Type(ctx context.Context) attr.Type {
	return ClustersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClustersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cluster_name": basetypes.StringType{},
		"inbound": basetypes.ListType{
			ElemType: types.StringType,
		},
		"outbound": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}
