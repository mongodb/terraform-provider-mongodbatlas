// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package controlplaneipaddresses

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"inbound": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"aws": schema.MapAttribute{
						ElementType: types.ListType{
							ElemType: types.StringType,
						},
						Computed:            true,
						Description:         "Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.",
						MarkdownDescription: "Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.",
					},
					"azure": schema.MapAttribute{
						ElementType: types.ListType{
							ElemType: types.StringType,
						},
						Computed:            true,
						Description:         "Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.",
						MarkdownDescription: "Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.",
					},
					"gcp": schema.MapAttribute{
						ElementType: types.ListType{
							ElemType: types.StringType,
						},
						Computed:            true,
						Description:         "Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.",
						MarkdownDescription: "Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.",
					},
				},
				CustomType: InboundType{
					ObjectType: types.ObjectType{
						AttrTypes: InboundValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "List of inbound IP addresses to the Atlas control plane, categorized by cloud provider. If your application allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your API requests can reach the Atlas control plane.",
				MarkdownDescription: "List of inbound IP addresses to the Atlas control plane, categorized by cloud provider. If your application allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your API requests can reach the Atlas control plane.",
			},
			"outbound": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"aws": schema.MapAttribute{
						ElementType: types.ListType{
							ElemType: types.StringType,
						},
						Computed:            true,
						Description:         "Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.",
						MarkdownDescription: "Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.",
					},
					"azure": schema.MapAttribute{
						ElementType: types.ListType{
							ElemType: types.StringType,
						},
						Computed:            true,
						Description:         "Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.",
						MarkdownDescription: "Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.",
					},
					"gcp": schema.MapAttribute{
						ElementType: types.ListType{
							ElemType: types.StringType,
						},
						Computed:            true,
						Description:         "Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.",
						MarkdownDescription: "Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.",
					},
				},
				CustomType: OutboundType{
					ObjectType: types.ObjectType{
						AttrTypes: OutboundValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "List of outbound IP addresses from the Atlas control plane, categorized by cloud provider. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that Atlas can communicate with your webhooks and KMS.",
				MarkdownDescription: "List of outbound IP addresses from the Atlas control plane, categorized by cloud provider. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that Atlas can communicate with your webhooks and KMS.",
			},
		},
	}
}

type TFControlPlaneIpAddressesModel struct {
	Inbound  InboundValue  `tfsdk:"inbound"`
	Outbound OutboundValue `tfsdk:"outbound"`
}

var _ basetypes.ObjectTypable = InboundType{}

type InboundType struct {
	basetypes.ObjectType
}

func (t InboundType) Equal(o attr.Type) bool {
	other, ok := o.(InboundType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InboundType) String() string {
	return "InboundType"
}

func (t InboundType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	awsAttribute, ok := attributes["aws"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws is missing from object`)

		return nil, diags
	}

	awsVal, ok := awsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws expected to be basetypes.MapValue, was: %T`, awsAttribute))
	}

	azureAttribute, ok := attributes["azure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure is missing from object`)

		return nil, diags
	}

	azureVal, ok := azureAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure expected to be basetypes.MapValue, was: %T`, azureAttribute))
	}

	gcpAttribute, ok := attributes["gcp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gcp is missing from object`)

		return nil, diags
	}

	gcpVal, ok := gcpAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gcp expected to be basetypes.MapValue, was: %T`, gcpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InboundValue{
		Aws:   awsVal,
		Azure: azureVal,
		Gcp:   gcpVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewInboundValueNull() InboundValue {
	return InboundValue{
		state: attr.ValueStateNull,
	}
}

func NewInboundValueUnknown() InboundValue {
	return InboundValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInboundValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InboundValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InboundValue Attribute Value",
				"While creating a InboundValue value, a missing attribute value was detected. "+
					"A InboundValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InboundValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InboundValue Attribute Type",
				"While creating a InboundValue value, an invalid attribute value was detected. "+
					"A InboundValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InboundValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InboundValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InboundValue Attribute Value",
				"While creating a InboundValue value, an extra attribute value was detected. "+
					"A InboundValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InboundValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInboundValueUnknown(), diags
	}

	awsAttribute, ok := attributes["aws"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws is missing from object`)

		return NewInboundValueUnknown(), diags
	}

	awsVal, ok := awsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws expected to be basetypes.MapValue, was: %T`, awsAttribute))
	}

	azureAttribute, ok := attributes["azure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure is missing from object`)

		return NewInboundValueUnknown(), diags
	}

	azureVal, ok := azureAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure expected to be basetypes.MapValue, was: %T`, azureAttribute))
	}

	gcpAttribute, ok := attributes["gcp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gcp is missing from object`)

		return NewInboundValueUnknown(), diags
	}

	gcpVal, ok := gcpAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gcp expected to be basetypes.MapValue, was: %T`, gcpAttribute))
	}

	if diags.HasError() {
		return NewInboundValueUnknown(), diags
	}

	return InboundValue{
		Aws:   awsVal,
		Azure: azureVal,
		Gcp:   gcpVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewInboundValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InboundValue {
	object, diags := NewInboundValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInboundValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InboundType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInboundValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInboundValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInboundValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInboundValueMust(InboundValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InboundType) ValueType(ctx context.Context) attr.Value {
	return InboundValue{}
}

var _ basetypes.ObjectValuable = InboundValue{}

type InboundValue struct {
	Aws   basetypes.MapValue `tfsdk:"aws"`
	Azure basetypes.MapValue `tfsdk:"azure"`
	Gcp   basetypes.MapValue `tfsdk:"gcp"`
	state attr.ValueState
}

func (v InboundValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["aws"] = basetypes.MapType{
		ElemType: types.ListType{
			ElemType: types.StringType,
		},
	}.TerraformType(ctx)
	attrTypes["azure"] = basetypes.MapType{
		ElemType: types.ListType{
			ElemType: types.StringType,
		},
	}.TerraformType(ctx)
	attrTypes["gcp"] = basetypes.MapType{
		ElemType: types.ListType{
			ElemType: types.StringType,
		},
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Aws.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aws"] = val

		val, err = v.Azure.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure"] = val

		val, err = v.Gcp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gcp"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InboundValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InboundValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InboundValue) String() string {
	return "InboundValue"
}

func (v InboundValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	awsVal, d := types.MapValue(types.ListType{
		ElemType: types.StringType,
	}, v.Aws.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aws": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"azure": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"gcp": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
		}), diags
	}

	azureVal, d := types.MapValue(types.ListType{
		ElemType: types.StringType,
	}, v.Azure.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aws": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"azure": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"gcp": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
		}), diags
	}

	gcpVal, d := types.MapValue(types.ListType{
		ElemType: types.StringType,
	}, v.Gcp.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aws": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"azure": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"gcp": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"aws": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"azure": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"gcp": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aws":   awsVal,
			"azure": azureVal,
			"gcp":   gcpVal,
		})

	return objVal, diags
}

func (v InboundValue) Equal(o attr.Value) bool {
	other, ok := o.(InboundValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Aws.Equal(other.Aws) {
		return false
	}

	if !v.Azure.Equal(other.Azure) {
		return false
	}

	if !v.Gcp.Equal(other.Gcp) {
		return false
	}

	return true
}

func (v InboundValue) Type(ctx context.Context) attr.Type {
	return InboundType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InboundValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aws": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"azure": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"gcp": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

var _ basetypes.ObjectTypable = OutboundType{}

type OutboundType struct {
	basetypes.ObjectType
}

func (t OutboundType) Equal(o attr.Type) bool {
	other, ok := o.(OutboundType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OutboundType) String() string {
	return "OutboundType"
}

func (t OutboundType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	awsAttribute, ok := attributes["aws"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws is missing from object`)

		return nil, diags
	}

	awsVal, ok := awsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws expected to be basetypes.MapValue, was: %T`, awsAttribute))
	}

	azureAttribute, ok := attributes["azure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure is missing from object`)

		return nil, diags
	}

	azureVal, ok := azureAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure expected to be basetypes.MapValue, was: %T`, azureAttribute))
	}

	gcpAttribute, ok := attributes["gcp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gcp is missing from object`)

		return nil, diags
	}

	gcpVal, ok := gcpAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gcp expected to be basetypes.MapValue, was: %T`, gcpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OutboundValue{
		Aws:   awsVal,
		Azure: azureVal,
		Gcp:   gcpVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOutboundValueNull() OutboundValue {
	return OutboundValue{
		state: attr.ValueStateNull,
	}
}

func NewOutboundValueUnknown() OutboundValue {
	return OutboundValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOutboundValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OutboundValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OutboundValue Attribute Value",
				"While creating a OutboundValue value, a missing attribute value was detected. "+
					"A OutboundValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OutboundValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OutboundValue Attribute Type",
				"While creating a OutboundValue value, an invalid attribute value was detected. "+
					"A OutboundValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OutboundValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OutboundValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OutboundValue Attribute Value",
				"While creating a OutboundValue value, an extra attribute value was detected. "+
					"A OutboundValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OutboundValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOutboundValueUnknown(), diags
	}

	awsAttribute, ok := attributes["aws"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws is missing from object`)

		return NewOutboundValueUnknown(), diags
	}

	awsVal, ok := awsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws expected to be basetypes.MapValue, was: %T`, awsAttribute))
	}

	azureAttribute, ok := attributes["azure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure is missing from object`)

		return NewOutboundValueUnknown(), diags
	}

	azureVal, ok := azureAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure expected to be basetypes.MapValue, was: %T`, azureAttribute))
	}

	gcpAttribute, ok := attributes["gcp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gcp is missing from object`)

		return NewOutboundValueUnknown(), diags
	}

	gcpVal, ok := gcpAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gcp expected to be basetypes.MapValue, was: %T`, gcpAttribute))
	}

	if diags.HasError() {
		return NewOutboundValueUnknown(), diags
	}

	return OutboundValue{
		Aws:   awsVal,
		Azure: azureVal,
		Gcp:   gcpVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOutboundValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OutboundValue {
	object, diags := NewOutboundValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOutboundValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OutboundType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOutboundValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOutboundValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOutboundValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOutboundValueMust(OutboundValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OutboundType) ValueType(ctx context.Context) attr.Value {
	return OutboundValue{}
}

var _ basetypes.ObjectValuable = OutboundValue{}

type OutboundValue struct {
	Aws   basetypes.MapValue `tfsdk:"aws"`
	Azure basetypes.MapValue `tfsdk:"azure"`
	Gcp   basetypes.MapValue `tfsdk:"gcp"`
	state attr.ValueState
}

func (v OutboundValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["aws"] = basetypes.MapType{
		ElemType: types.ListType{
			ElemType: types.StringType,
		},
	}.TerraformType(ctx)
	attrTypes["azure"] = basetypes.MapType{
		ElemType: types.ListType{
			ElemType: types.StringType,
		},
	}.TerraformType(ctx)
	attrTypes["gcp"] = basetypes.MapType{
		ElemType: types.ListType{
			ElemType: types.StringType,
		},
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Aws.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aws"] = val

		val, err = v.Azure.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure"] = val

		val, err = v.Gcp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gcp"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OutboundValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OutboundValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OutboundValue) String() string {
	return "OutboundValue"
}

func (v OutboundValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	awsVal, d := types.MapValue(types.ListType{
		ElemType: types.StringType,
	}, v.Aws.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aws": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"azure": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"gcp": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
		}), diags
	}

	azureVal, d := types.MapValue(types.ListType{
		ElemType: types.StringType,
	}, v.Azure.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aws": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"azure": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"gcp": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
		}), diags
	}

	gcpVal, d := types.MapValue(types.ListType{
		ElemType: types.StringType,
	}, v.Gcp.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aws": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"azure": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"gcp": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"aws": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"azure": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"gcp": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aws":   awsVal,
			"azure": azureVal,
			"gcp":   gcpVal,
		})

	return objVal, diags
}

func (v OutboundValue) Equal(o attr.Value) bool {
	other, ok := o.(OutboundValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Aws.Equal(other.Aws) {
		return false
	}

	if !v.Azure.Equal(other.Azure) {
		return false
	}

	if !v.Gcp.Equal(other.Gcp) {
		return false
	}

	return true
}

func (v OutboundValue) Type(ctx context.Context) attr.Type {
	return OutboundType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OutboundValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aws": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"azure": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"gcp": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
	}
}
