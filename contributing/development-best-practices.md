
# Development Best Practices

## Table of Contents
- [Scaffolding Initial Code and File Structure](#scaffolding-initial-code-and-file-structure)
- [Auto-Generating Resources \& Data Sources (Internal tool)](#auto-generating-resources--data-sources)
  - [Customizing Generated Resources \& Data Sources](#customizing-generated-resources--data-sources)

## Scaffolding Initial Code and File Structure

**Note**: This command is relevant when developing a new resource or data source manually. For full autogeneration, reference the section below.

This command can be used the following way:
```bash
make scaffold resource_name=streamInstance type=resource
```
- **resource_name**: The name of the resource, which must be defined in camel case.
- **type**: Describes the type of resource being created. There are 3 different types: `resource`, `data-source`, `plural-data-source`.

This will generate resource/data source files and accompanying test files needed for starting the development, and will contain multiple comments with `TODO:` statements which give guidance for the development.

As a follow up step, use [Auto-Generating Resources](#auto-generating-resources) to autogenerate the schema via the Open API specification. This will require making adjustments to the generated `./internal/service/<resource_name>/tfplugingen/generator_config.yml` file.

## Auto-Generating Resources & Data Sources (Internal tool)

The generation command makes use of a configuration file defined under [`./tools/codegen/config.yml`](../tools/codegen/config.yml). The structure of this configuration file can be found under  [`./tools/codegen/config/config_model.go`](../tools/codegen/config/config_model.go).

The generation command takes a single optional argument `resource_name`. If not provided, all resources defined in the configuration are generated.

```bash
make resource-generation-pipeline resource_name=search_deployment_api
```

If you wish to generate resource/data source code without fetching latest changes from the API Spec, use the following command:
```bash
make resource-code-generation
```

As a result, content of schemas and models will be written into the corresponding resource packages:
`./internal/serviceapi/<resource-package>/resource_schema.go`

And operations will be written into:
`./internal/serviceapi/<resource-package>/resource.go`

Data sources are automatically generated as part of the same generation process when a `datasources` block is configured in `tools/codegen/config.yml`. The tool generates both singular and plural data sources:

**Singular Data Source** (generated when `datasources.read` is configured):
- `./internal/serviceapi/<resource-package>/data_source_schema.go`
- `./internal/serviceapi/<resource-package>/data_source.go`

**Plural Data Source** (generated when `datasources.list` is configured):
- `./internal/serviceapi/<resource-package>/plural_data_source_schema.go`
- `./internal/serviceapi/<resource-package>/plural_data_source.go`

## Customizing Generated Resources & Data Sources

There are two primary ways to customize the behavior and shape of autogenerated resources and data sources: **configuration-driven** options in `tools/codegen/config.yml` and **custom code hooks** implemented on the generated types.

### Configuration-Driven Customizations (`tools/codegen/config.yml`)

These options are defined per resource in `tools/codegen/config.yml` (see the configuration model in `tools/codegen/config/config_model.go` and `tools/codegen/codespec/config.go`) and allow you to adjust how schemas and docs are generated:

- **`ignores`**: Hide attributes that are not useful to end users.
- **`aliases`**: Aligns attribute names with existing provider conventions so configurations feel consistent across manual and autogenerated resources. For example:
  - `group_id` → `project_id`

- **Computability and requiredness overrides**: Use `schema.overrides.<attribute>.computability` to override whether an attribute is **required**, **optional**, or **computed** to better match real API behavior. This includes support for attributes that are both **optional + computed**, which is useful for fields that may be omitted by users but are defaulted or populated by the API (for example, defaulted fields on clusters).

- **Description overrides**: Use `schema.overrides.<attribute>.description` sparingly to correct or clarify attribute descriptions when the OpenAPI or Atlas documentation is misleading, incomplete, or too low-level. Keep wording consistent with other resources and focused on what the Terraform user needs to know, without changing the underlying API semantics.

- **`sensitive`**: Marks attributes as sensitive, which is especially helpful when the API specification does not annotate secret properties with `format: password`. Use this to ensure secrets are not displayed in plan/apply output or stored in plain text in state.

- **Type overrides for collection types**: For collection attributes, you can override the default collection kind (e.g. `list` vs `set`) to better match the behavior of the underlying API. This is only supported for collection types and should be used when ordering or uniqueness semantics matter to users.

When adding or changing these options, keep changes minimal, documented, and consistent with existing patterns in the same resource family.

### Custom Code Hooks (`internal/common/autogen/custom_hooks.go`)

For cases where configuration alone is not sufficient, autogenerated resources and data sources can implement hook interfaces defined in `internal/common/autogen/custom_hooks.go`. These hooks allow you to intercept and customize behavior around resource/data source logic while still relying on the default generator for the bulk of the implementation.

Available hooks include:

- **`PreReadAPICallHook` / `PostReadAPICallHook`** (relevant for both resource and data sources)
- **`PreCreateAPICallHook` / `PostCreateAPICallHook`**
- **`PreUpdateAPICallHook` / `PostUpdateAPICallHook`**
- **`PreDeleteAPICallHook` / `PostDeleteAPICallHook`**

To use them, implement the relevant interface(s) on the autogenerated resource or data source struct in the corresponding `internal/serviceapi/<resource-package>/` package. Resource/data source implementation will detect and invoke these functions if available.

An example implementation can be found in:

- `internal/serviceapi/orgserviceaccountsecretapi/resource_custom_hooks.go`

In this example, a custom `PostReadAPICall` implementation filters the raw API response to return only the specific secret matching the Terraform resource’s ID, mimicking the read response of a single secret which is not available in the API.

